<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>组件 - Firmament Autopilot</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u7ec4\u4ef6";
    var mkdocs_page_input_path = "module.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Firmament Autopilot</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">概述</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../getting_started/">快速上手</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../device/">驱动和设备</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">组件</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#_1">组件</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#console">Console控制台</a></li>
        
            <li><a class="toctree-l3" href="#umcn">uMCN消息订阅/发布模块</a></li>
        
            <li><a class="toctree-l3" href="#param">Param参数模块</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../mbd/">模型合入</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../simulation/">仿真</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../contribute/">贡献</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Firmament Autopilot</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>组件</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/FirmamentPilot/doc_src/edit/master/docs/module.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="_1">组件</h1>
<p>FMT提供了功能强大的系统组件，各种组件提供了系统的大部分功能实现。由于硬件虚拟层（HAL）的引入，各个组件模块可以做到跟硬件平台无关，支持在各个不用的硬件平台上使用。用户只需要根据当前的硬件平台资源和驱动，来决定要使用哪些组件模块。
这里，我们将介绍FMT中常用的一些组件。</p>
<h2 id="console">Console控制台</h2>
<p>控制台组件供了控制台的输入/输出功能，主要用于调试信息的打印以及命令行的交互功能。console可以被映射到不同的设备上，如串口，USB等。</p>
<h3 id="_2">设置控制台设备</h3>
<p>调用如下函数来将console设置到<code>dev_name</code>对应的设备上。</p>
<pre><code class="c">fmt_err console_set_device(char* dev_name);
</code></pre>

<p>console默认使用<code>serial1</code>设备，当用户连接QGC，并在<code>Mavlink Console</code>输入任意字符，console将被自动切换到<code>mav_console</code>设备上。</p>
<p>当前console支持的设备名称如下：
- <code>serialx</code>： 标准串口设备，默认使用<code>serial1</code>
- <code>mav_console</code>: 基于mavlink协议的虚拟控制台设备。它将console的输入/输出数据封装为<code>MAVLINK_MSG_ID_SERIAL_CONTROL</code>的包，再通过串口或者USB进行发送，以支持QGC的<code>Mavlink Console</code>功能，如图所示：</p>
<p><img alt="mav_console" src="../img/mav_console.png" /></p>
<h3 id="shell">绑定Shell设备</h3>
<p>调用如下函数将设备绑定到shell。绑定后，对应设备的输入将送给shell进行命令解析。若传入的<code>dev=NULL</code>，则默认将当前<code>console</code>的设备绑定到shell。</p>
<pre><code class="c">fmt_err console_mount_shell(rt_device_t dev);
</code></pre>

<h3 id="_3">控制台打印</h3>
<p>控制台提供了如下两个函数来打印信息到控制台设备。</p>
<pre><code class="c">uint32_t console_printf(const char* fmt, ...);
uint32_t console_write(const char* content, uint32_t len);
</code></pre>

<p>常用的<code>console_printf()</code>用法类似<code>printf()</code>，支持各种格式化打印，且支持中断函数中打印，如：</p>
<pre><code class="c">console_printf(&quot;%f %d %x\n&quot;, 0.2, 33, 0xFF);
</code></pre>

<p><code>console_write()</code>函数则提供了控制台数据直接写入的功能，如:</p>
<pre><code class="c">console_write(buffer, sizeof(buffer));
</code></pre>

<h2 id="umcn">uMCN消息订阅/发布模块</h2>
<p>uMCN (Micro Multi-Communication Node) 提供基于订阅/发布模式的安全跨进程通信方式，为FMT各个Task，模块之间进行信息交换的主要方式。</p>
<h3 id="_4">定义消息</h3>
<p>定义一条新的uMCN非常简单。比如要定义一条新的消息<code>my_mcn_topic</code>，其消息（topic）内容为：</p>
<pre><code class="c">typedef struct {
    uint32_t a;
    float b;
    int8_t c[4];
} test_data;
</code></pre>

<p>首先需要定义消息。在任意地方（通常为发布该topic的源文件的头部）添加如下定义：</p>
<pre><code class="c">MCN_DEFINE(my_mcn_topic, sizeof(test_data));
</code></pre>

<p>其中<code>my_mcn_topic</code>为该topic的名字，<code>sizeof(test_data)</code>为消息内容的长度。所以理论上可以用uMCN传递任意消息类型。<strong>注意：</strong>同一个消息只能被定义一次。</p>
<p>然后调用函数<code>mcn_advertise(McnHub* hub, int (*echo)(void* parameter))</code>注册该条消息：</p>
<pre><code class="c">mcn_advertise(MCN_ID(my_mcn_topic), _my_mcn_topic_echo);
</code></pre>

<p>其中<code>_my_mcn_topic_echo</code>为该条消息添加<em>echo</em>打印函数。当前控制台输入指令<code>mcn echo my_mcn_topic</code>，将调用该条消息的<em>echo</em>函数来打印消息内容。打印的格式可以根据用户需要自行定义，比如<code>my_mcn_topic</code>的<em>echo</em>函数可以这样定义：</p>
<pre><code class="c">static int _my_mcn_topic_echo(void* param)
{
    test_data data;
    if(mcn_copy_from_hub((McnHub*)param, &amp;data) == FMT_EOK){
        console_printf(&quot;a:%d b:%f c:%c %c %c %c\n&quot;, data.a, data.b,
                        data.c[0], data.c[1], data.c[2], data.c[3]);
    }
    return 0;
}
</code></pre>

<h3 id="_5">消息发布</h3>
<p>发布消息使用函数<code>mcn_publish(McnHub* hub, const void* data)</code>。但在发布之前，需要确认是否需要申明该条消息。如果是在定义消息的文件，则无需申明，否则，需要在当前文件的头部添加消息的申明：</p>
<pre><code class="c">MCN_DECLARE(my_mcn_topic);
</code></pre>

<p>然后调用消息发布函数：</p>
<pre><code class="c">mcn_publish(MCN_ID(my_mcn_topic), &amp;my_data);
</code></pre>

<p>这里的<code>my_data</code>为<code>test_data</code>数据类型，跟MCN_DEFINE()消息定义时的数据类型相同。</p>
<h3 id="_6">消息订阅</h3>
<p>uMCN支持同步/异步消息订阅。同样，在订阅消息的文件中，可能需要添加消息的申明：</p>
<pre><code class="c">MCN_DECLARE(my_mcn_topic);
</code></pre>

<p>然后调用消息订阅函数<code>mcn_subscribe(McnHub* hub, MCN_EVENT_HANDLE event_t, void (*cb)(void* parameter))</code>。其中<code>cb</code>为消息发布的回调函数，在每次发布消息时，回调函数将被调用。 <strong>注意：</strong>回调函数将在发布消息的线程中被调用。</p>
<p><code>event_t</code>为用于消息同步的事件句柄，当需要进行同步消息订阅时：</p>
<pre><code class="c">rt_sem_t event = rt_sem_create(&quot;my_event&quot;, 0, RT_IPC_FLAG_FIFO);
McnNode_t my_nod = mcn_subscribe(MCN_ID(my_mcn_topic), event, NULL);
</code></pre>

<p>如果不需要进行同步消息订阅：</p>
<pre><code class="c">McnNode_t my_nod = mcn_subscribe(MCN_ID(my_mcn_topic), NULL, NULL);
</code></pre>

<h3 id="_7">消息读取</h3>
<p>如果是采用同步订阅的方式，则采用如下方式读取消息。<code>mcn_poll_sync()</code>函数将挂起当前线程，直到收到新的消息或者等待超时。</p>
<pre><code class="c">test_data read_data;
if(mcn_poll_sync(my_nod, RT_WAIT_FOREVER)){
    mcn_copy(MCN_ID(my_mcn_topic), my_nod, &amp;read_data);
}
</code></pre>

<p>如果是采用一部订阅方式，使用如下的方式读取消息。<code>mcn_poll()</code>会立马返回当前是否有新的消息发布。</p>
<pre><code class="c">test_data read_data;
if(mcn_poll(my_nod){
    mcn_copy(MCN_ID(my_mcn_topic), my_nod, &amp;read_data);
}
</code></pre>

<h3 id="umcn_1">uMCN指令</h3>
<p>FMT内置uMCN的指令，指令用法如下：</p>
<pre><code class="shell">msh /&gt;mcn
usage: mcn [OPTION] ACTION [ARGS]

Action:
 list  List all uMCN topics.
 echo  Echo a uMCN topic.

Option:
 -c, --cnt     Set topic echo count, e.g, -c=10 will echo 10 times.
 -p, --period  Set topic echo period(ms), -p=0 inherits topic period. The default period is 500ms.
</code></pre>

<p>输入<code>mcn list</code>将显示当前系统所有的topic</p>
<pre><code class="shell">msh /&gt;mcn list
      Topic       #SUB   Freq(Hz)   Echo
---------------- ------ ---------- ------
usb_status          1      21.7     true
sensor_imu          1      500.0    true
sensor_mag          1      100.0    true
sensor_baro         1      100.0    true
sensor_gps          1      10.0     true
ins_output          3      500.0    true
fms_output          2      125.0    false
control_output      2      250.0    false
pilot_cmd           1       0.0     true
</code></pre>

<p>其中<strong>Topic</strong>为消息名称，<strong>#SUB</strong>为消息订阅者数量，<strong>Freq</strong>为消息发布频率，<strong>Echo</strong>表示该条消息是否提供了<em>echo</em>打印函数。</p>
<p>对于提供了<em>echo</em>函数的消息，可以输入<code>mcn echo [topic_name]</code>来打印消息。比如输入</p>
<pre><code class="shell">echo sensor_imu
</code></pre>

<p>将打印IMU的数据</p>
<pre><code class="shell">msh /&gt;mcn echo sensor_imu
gyr:-0.000870 -0.002555 -0.003110 acc:0.011333 0.083641 -9.862786
gyr:-0.001118 -0.001791 0.001414 acc:-0.067505 -0.048334 -9.854862
gyr:0.002485 0.005287 0.005572 acc:-0.040842 -0.008587 -9.773908
gyr:-0.000103 -0.001102 0.003385 acc:-0.092554 -0.013108 -9.854832
gyr:-0.001078 0.002592 -0.003151 acc:-0.040336 0.019121 -9.748902
......
</code></pre>

<p><code>mcn echo</code>指令支持<code>-c</code>和<code>-p</code>Option来设置消息打印的<strong>条数</strong>和<strong>频率</strong>，默认打印频率500ms。 比如如下指令将打印10条消息，打印频率为100ms。<code>-p=0</code>表示按照消息发布的频率进行打印。</p>
<pre><code class="shell">msh /&gt;mcn echo -c=10 -p=100 sensor_mag
mag:0.274922 -0.024422 -0.159042
mag:0.276737 -0.022779 -0.159433
mag:0.274406 -0.024486 -0.161853
mag:0.276287 -0.023486 -0.159781
mag:0.275939 -0.022636 -0.159832
mag:0.274942 -0.024098 -0.160137
mag:0.275403 -0.023519 -0.159008
mag:0.278422 -0.024728 -0.158227
mag:0.275549 -0.023282 -0.160785
mag:0.274039 -0.025209 -0.159165
</code></pre>

<h2 id="param">Param参数模块</h2>
<p>param参数模块提供了参数的读取，存储和修改功能。参数将以xml文件的形式存储在存储设备，如SD卡上。系统上电会，会读取参数文件，并加载文件中的参数。若参数文件不存在，则使用默认的参数值。参数也会被记录到<code>blog</code>中，供Simulink模型使用。目前参数支持的数据类型包括</p>
<pre><code class="c">enum param_type_t {
    PARAM_TYPE_INT8 = 0,
    PARAM_TYPE_UINT8,
    PARAM_TYPE_INT16,
    PARAM_TYPE_UINT16,
    PARAM_TYPE_INT32,
    PARAM_TYPE_UINT32,
    PARAM_TYPE_FLOAT,
    PARAM_TYPE_DOUBLE,
    PARAM_TYPE_UNKNOWN = 0xFF
};
</code></pre>

<h3 id="_8">参数定义</h3>
<p>参数以Group为单位，其中每个Group可以包含一到多个参数。例如，定义新的<em>float</em>类型的参数<code>my_param1</code>和<em>uint32</em>类型的参数<code>my_param2</code>，它们的Group名称为<code>my_group</code>，那么可以按如下步骤添加新的参数：
1. 申明Group: 在<code>param.h</code>中申明新的组<code>my_group</code></p>
<pre><code class="c">typedef struct {
    ......
    param_group_t   PARAM_GROUP(my_group);
} param_list_t;
</code></pre>

<ol>
<li>定义Group: 在<code>param.c</code>中定义新的组<code>my_group</code></li>
</ol>
<pre><code class="c">param_list_t param_list = { 
    ......
    PARAM_DEFINE_GROUP(my_group),
};
</code></pre>

<ol>
<li>申明参数: 在<code>param.h</code>中添加新的参数申明</li>
</ol>
<pre><code class="c">typedef struct {
    PARAM_DECLARE(my_param1);
    PARAM_DECLARE(my_param2);
} PARAM_GROUP(my_group);
</code></pre>

<ol>
<li>定义参数：在<code>param.c</code>中定义新的参数</li>
</ol>
<pre><code class="c">PARAM_GROUP(my_group) PARAM_DECLARE_GROUP(my_group) = \
{
    PARAM_DEFINE_FLOAT(my_param1, 0.5),
    PARAM_DEFINE_UINT32(my_param2, 1),
};
</code></pre>

<p>以上就定义了一个两个新的参数<code>my_param1</code>（默认值0.5）和<code>my_param2</code>（默认值1）。如果是在已有Group中添加新的参数，那么则可以省去步骤1和步骤2.</p>
<h3 id="_9">参数读取</h3>
<p>参数模块提供了如下宏定义来快速获取参数的值,需要选择对应参数类型的宏并传入组名称和参数名称. </p>
<pre><code class="c">#define PARAM_GET_INT8(_group, _name)
#define PARAM_GET_UINT8(_group, _name)
#define PARAM_GET_INT16(_group, _name)
#define PARAM_GET_UINT16(_group, _name)
#define PARAM_GET_INT32(_group, _name)
#define PARAM_GET_UINT32(_group, _name)
#define PARAM_GET_FLOAT(_group, _name)
#define PARAM_GET_DOUBLE(_group, _name)
</code></pre>

<p>除此之外,还可以通过如下函数来获取参数:</p>
<pre><code class="c">param_t* param_get(char* group_name, char* param_name);
param_t* param_get_by_name(const char* param_name);
param_t* param_get_by_full_name(const char* group_name, const char* param_name);
</code></pre>

<p>这些函数使用轮询的方式查找与<code>group_name</code>和<code>param_name</code>匹配的参数. 当参数较多时,查找速度较慢,不建议在程序中使用,仅供系统指令(syscmd)模块使用.</p>
<h3 id="_10">参数设置</h3>
<p>类似参数读取,参数设置也提供了对应的宏来快速设置参数的值:</p>
<pre><code class="c">#define PARAM_SET_INT8(_group, _name, _val)
#define PARAM_SET_UINT8(_group, _name, _val)
#define PARAM_SET_INT16(_group, _name, _val)
#define PARAM_SET_UINT16(_group, _name, _val)
#define PARAM_SET_INT32(_group, _name, _val)
#define PARAM_SET_UINT32(_group, _name, _val)
#define PARAM_SET_FLOAT(_group, _name, _val)
#define PARAM_SET_DOUBLE(_group, _name, _val)
</code></pre>

<p>同样,也可以使用如下函数来设置与<code>group_name</code>和<code>param_name</code>匹配的参数.</p>
<pre><code class="c">fmt_err param_set_val(param_t* param, void* val);
fmt_err param_set_val_by_name(char* param_name, void* val);
fmt_err param_set_val_by_full_name(char* group_name, char* param_name, void* val);
fmt_err param_set_string_val(param_t* param, char* val);
fmt_err param_set_string_val_by_name(char* param_name, char* val);
fmt_err param_set_string_val_by_full_name(char* group_name, char* param_name, char* val);
</code></pre>

<p>参数设置完后,默认不会保存到参数文件.如需将当前参数保存,需要调用<code>param_save(char* path)</code>函数,其中<code>path</code>为参数文件的路径名称,默认路径为<code>PARAM_FILE_NAME</code>.</p>
<h3 id="param_1">param指令</h3>
<p>FMT提供了<code>param</code>指令来对参数进行操作,其基本用法如下所示:</p>
<pre><code class="shell">msh /&gt;param
usage: param [OPTION] ACTION [ARGS]

Action:
 list   List group(s) parameters.
 group  List all parameter groups.
 set    Set parameter.
 get    Get parameter.
 save   Save parameters to file.
 load   Load parameters from file.

Option:
 -s, --save  Save parameter value.
</code></pre>

<ul>
<li><code>param list</code>: 显示所有的Group和Group中的Parameter:</li>
</ul>
<pre><code class="shell">msh /&gt;param list
SYSTEM:
           BLOG_MODE: 0
CALIB:
          GYRO0_XOFF: 0.000000
          GYRO0_YOFF: 0.000000
          GYRO0_ZOFF: 0.000000
          ......
</code></pre>

<p>如果在list后加上Group的名称,则只显示对应Group的参数:</p>
<pre><code class="shell">msh /&gt;param list SYSTEM
SYSTEM:
           BLOG_MODE: 0
</code></pre>

<ul>
<li><code>param group</code>: 显示所有的Group:</li>
</ul>
<pre><code class="shell">msh /&gt;param group
  Parameter Groups
--------------------
SYSTEM
CALIB
</code></pre>

<ul>
<li><code>param set</code>: 设置参数的值,其用法如下.其中方括号表示可选项,尖括号为必填项.</li>
</ul>
<pre><code class="shell">param set [group] &lt;parameter&gt; &lt;value&gt;
</code></pre>

<p>比如要将<code>BLOG_MODE</code>设置为2,可以使用如下指令:</p>
<pre><code class="shell">param set SYSTEM BLOG_MODE 2
</code></pre>

<p>也可以简写为如下指令.但是注意,由于这里没有指定Group,如果存在两个相同名字但是在不同Group的参数,则会写入第一个找到的参数.</p>
<pre><code>param set BLOG_MODE 2
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../mbd/" class="btn btn-neutral float-right" title="模型合入">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../device/" class="btn btn-neutral" title="驱动和设备"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/FirmamentPilot/doc_src/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../device/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../mbd/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
